# pi-builder
**Pi-builder** - это удобный и расширяемый инструмент для сборки образов [Arch Linux ARM](https://archlinuxarm.org) для Raspberry Pi с использованием [Docker](https://www.docker.com).

### Проблема
Обычно для сборки операционок разработчики дистрибутивов используют набор шелл-скриптов. У каждого дистрибутива они, как правило, свои. С их помощью создается чрут с нужными пакетами, правятся конфиги, добавляются пользователи и выполняются иные операции. Таким образом обеспечивается необходимый минимум для успешной загрузки, работы и дальнейшей кастомизации оси руками конечного пользователя.

Однако, если вы создаете какой-то собственный продукт на основе обноплатного компьютера (маленький роутер, IP-камеру или систему управления умным домом, что угодно), скорее всего вам захочется как-нибудь задокументировать все изменения, которые вы внесли в свежеустановленную операционную систему и обеспечить себе возможность повторить эти настройки, не бояссь забыть о каком-нибудь важном действии, типа настройки sysctl.

Типичное решение в данном случае - написать большой и страшный скрипт, выполняющий все необходимые действия либо над развернутым на разработческой машине корнем, либо прямо на устройстве. При использовании chroot и [binfmt_misc](https://en.wikipedia.org/wiki/Binfmt_misc), а так же при необходимости сохранения промежуточных стадий сборки сложность подобных скриптов сразу возрастает на порядок. А со временем они становятся абсолютно неподдерживаемыми.

### Что предлагает pi-builder?
**Pi-builder** - это новый подход к сборке целевой операционной системы для встраиваемых устройств. Он позволяет собирать образ так, как если бы это была не система для реальной железки, а обычный докер-контейнер. Сборка системы описывается стандартным синтаксисом [докерфайлов](https://docs.docker.com/engine/reference/builder) и выполняется в докере прямо на машине разработчика. Получившийся образ можно экспортировать на SD-карту и загрузить на Raspberry Pi.

### Что это дает?
* **Документирование и повторяемость сборок.** Докерфайлы - это практически готовая документация к последовательности действий, необходимых для настройки всей вашей системы.
* **Простота**. Ну серьезно, что может быть проще, чем написать докерфайл?
* **Скорость и кеширование сборок**. Сборка целевой системы может состоять из сотен сложных и долго выполняющихся команд. С помощью докера и его кешей вы можете не выполнять все эти команды каждый раз при сборке новой системы; сборка будет начинаться только с изменившихся команд, а результаты предыдущих будут браться из кеша.
* **Тестирование на реальном окружении**. Если вы разрабатываете какой-то софт, который должен работать на Raspberry Pi, совершенно логично тестировать его в том же окружении, в котором он будет работать на реальной железке - это избавит от многих потенциальных проблем.

### Как это работает?
Разработчики Arch Linux ARM (да и других систем) предоставляют для своих осей [архивы с минимальными корневыми ФС](https://mirror.yandex.ru/archlinux-arm/os/), которые можно развернуть на флешке и загрузиться с них. И поскольку это обычные корни, из них также можно сделать собственный базовый образ для докера с помощю механизма [FROM scratch](https://docs.docker.com/develop/develop-images/baseimages). Однако этот образ будет содержать исполняемые файлы и библиотеки с архитектурой `ARM`, и если ваша машина работает под другой архитектурой (скажем, `x86_64`), то ни одна команда внутри этого образа у вас не запустится.

Для того, чтобы иметь возможность исполнять файлы с другой архитектурой, ядро Linux имеет специальный механизм [binfmt_misc](https://en.wikipedia.org/wiki/Binfmt_misc), который позволяет установить кастомный интерпретатор для архитектуры, отличной от системной. Таким образом, можно настроить `binfmt_misc` для запуска ARM-бинарников с помощью эмулятора (в нашем случае - `qemu-arm-static` для `x86_64`). **Pi-builder** содержит [небольшой скрипт](https://github.com/pi-kvm/pi-builder/blob/master/tools/install-binfmt), настраивающий в хост-системе binfmt_misc, чтобы иметь возможность запускать исполняемые файлы на ARM.

Сборка операционной системы в терминологии **pi-builder** делится на последовательные **_стейджи_**, представляющие какой-либо отдельный аспект настройки оси. Например, стейдж [ro](https://github.com/pi-kvm/pi-builder/tree/master/stages/ro) включает в себя Dockerfile.part с необходимыми инструкциями, чтобы сделать на системе read-only корень, и конфиги для этого. Другой пример - стейдж [watchdog](https://github.com/pi-kvm/pi-builder/tree/master/stages/watchdog) включает все необходимое для настройки вачдога с оптимальными параметрами на Raspberry Pi.

Полный список стейджей, идущих в комплекте с pi-builder, можно посмотреть [тут](https://github.com/pi-kvm/pi-builder/tree/master/stages) или ниже. При сборке системы вы сами решаете, какие стейджи вам нужны, и просто включаете их в вашу конфигурацию. По сути, стейджи - это кусочки докерфайла которые при сборке склеиваются в указанной последовательности в один большой докерфайл и содержат все инструкции, которые будут выполнены на собираемой системе.

Последовательность сборки выглядит так:
1. **Pi-builder** скачивает статически скомпилированный qemu-arm-static от Debian и настраивает binfmt_misc глобально на вашей машине.
2. Далее скачивается образ Arch Linux ARM и заряжется в докер в качестве базового образа.
3. Производится сборка конейнера с необходимыми стейджами - установка пакетов, настройка конфигов, чистка и так далее.
4. В получившемся контейнере можно запустить оболочку с помощью `docker run` (или `make shell`), чтобы проверить, все ли в порядке.
5. С помощью утилиты [docker-extract](https://github.com/pi-kvm/pi-builder/blob/master/tools/docker-extract), входящей в состав **pi-builder**, контейнер извлекается из внутреннего хранилища докера и помещается в каталог как обыкновенная развернутая корневая ФС.
6. Готовую ФС можно скопировать на SD-карту и загрузить с нее Raspberry Pi.

### Как этим пользоваться?

Для сборки системы с помощью **pi-builder** вам понадобится свежий докер с возможностью запуска контейнера в привелегированном режиме (он требуется [вспомогательному образу](https://github.com/pi-kvm/pi-builder/blob/master/tools/Dockerfile.root) для установки binfmt_misc, форматирования SD-карты и некоторых других операций).

Вся работа с **pi-builder** выполняется с помощью главного [Makefile](https://github.com/pi-kvm/pi-builder/blob/master/Makefile) в корне репозитория. В его начале перечислены параметры, доступные для изменения; все остальные, начинающиеся с символа `_`, менять не рекомендуется (только если вы точно не знаете, что делаете).

```Makefile
CARD ?= /dev/mmcblk0  # Путь к вашей SD-карте, на нее будет устанавливаться собранная система командой make install
CARD_BOOT ?= $(CARD)p1  # Раздел для /boot
CARD_ROOT ?= $(CARD)p2  # Раздел для /

BOARD ?= rpi  # Целевая платформа Raspberry Pi; rpi-2 для Raspberry Pi 2
STAGES ?= __init__  # Список необходимых стейджей, об этом подробнее ниже

PROJECT ?= common  # Пространство имен для промежуточных образов, просто назовите как нравится
BUILD_OPTS ?=  # Всякие дополнительные опции для docker build
QEMU_ARM_STATIC_PLACE ?= /usr/bin/qemu-arm-static  # Путь к qemu-arm-static ВНУТРИ КОНТЕЙНЕРА
HOSTNAME ?= pi  # Имя хоста для получившейся системы
LOCALE ?= en_US.UTF-8  # Локаль будущей системы
TIMEZONE ?= Europe/Moscow  # Таймзона будущей системы
REPO_URL ?= http://mirror.yandex.ru/archlinux-arm  # Зеркало пакетов и всего загружаемого контента
```

Самые важные параметры - это `BOARD`, определяющий, под какую плату нужно собрать систему, `STAGES`, указывающий, какие стейджи необходимо включить и `CARD*`.

Например, вот так выглядит сборка системы с ридонли-корнем и вачдогом (выдержка из Makefile). Ее можно активировать с помощью команды `make rpi2`:
```Makefile
rpi2: binfmt
	make _rpi \
		BOARD=rpi-2 \
		BUILD_OPTS="--build-arg NEW_SSH_KEYGEN=$(shell uuidgen)" \
		STAGES="__init__ os watchdog ro rootssh __cleanup__"
```

Стейдж `__init__` всегда должен идти первым - он содержит инициализирующие инструкции для создания базового образа системы (`FROM scratch`). Далее идут стейджи для "обживания" системы - установки полезных пакетов, настройки вачдога, приведения системы к ридонли, настройки ключей SSH для рута и очистки от временных файлов.

Вы можете создать собственные стейджи и включить их в сборку наравне с комплектными. Для этого просто заведите каталог для вашего стейджа в папке `stages` и разместите в нем файл `Dockerfile.part` по аналогии с любым другим стейджем. Как вариант, можно сделать так, как это устроено в проекте [Pi-KVM](https://github.com/pi-kvm/pi-kvm/tree/master/os) (для которого, собственно, **pi-builder** и был разработан).

### Комплектные стейджи
* `__init__` - главный стейдж, формирующий базовый образ на основе корневой ФС Arch Linux ARM. Он ВСЕГДА должен идти первым в списке `STAGES`. 
* `os` - просто ставит некоторые пакеты и настраивает систему, чтобы в ней было несколько более комфортно жить. Просто [посмотрите его содержимое](https://github.com/pi-kvm/pi-builder/tree/master/stages/os).
* `ro` - превращает систему в ридонли-ось. В таком режиме Raspberry Pi можно просто выключать из розетки без предварительной подготовки, не боясь повреждения файловой системы и потери данных. Для того, чтобы временно включить систему на запись (для обновления, например), используйте команду `rw`; после всех изменений выполните команду `ro` для обратного перемонтирования в ридонли.
* `watchdog` - настраивает аппаратный вачдог.
* `rootssh` - удаляет пользователя `alarm`, блокирует пароль `root` и добавляет в его `~/.ssh/authorized_keys` ключи из каталога [stages/rootssh/pubkeys]. По умолчанию там лежат ключи разработчика **pi-builder** :D Кроме того, при в `BUILD_OPTS` параметра `--build-arg NEW_SSH_KEYGEN=$(shell uuidgen)` на этом стейдже будет всегда происходить пересборка системы, поскольку в конце него выполняется команда `ssh-keygen` для генерирования уникальных хостовых ключей. В обычной ситуации ее ручной запуск не требуется, но если система загружается в ридонли, у SSH нет возможности сгенерировать ключи самостоятельно даже при первой загрузке.
* `__cleanup__` - удаляет всякий мусор во временных папках, оставшийся от сборки.

### TL;DR
Как собрать систему и поставить ее на SD-карту:
```shell
$ git clone https://github.com/pi-kvm/pi-builder
$ cd pi-builder
$ make rpi2
$ make install
```

Как собрать систему со своим списком стейджей:
```shell
$ make _rpi BOARD=rpi-2 STAGES="__init__ os __cleanup__"
```

Остальные команды можно посмотреть так:
```shell
$ make
Available commands:
    make           # Print this help
    make rpi|rpi2  # Build Arch-ARM rootfs
    make shell     # Run Arch-ARM shell
    make binfmt    # Before build
    make scan      # Find all RPi devices in the local network
    make clean     # Remove the generated rootfs
    make format    # Format /dev/mmcblk0 to /dev/mmcblk0p1 (vfat), /dev/mmcblk0p2 (ext4)
    make install   # Install rootfs to partitions on /dev/mmcblk0
```

* **Важно**: проверьте в Makefile путь к SD-карте в переменных `CARD*`.
* **Очень важно**: положите в каталог [stages/rootssh/pubkeys](https://github.com/pi-kvm/pi-builder/tree/master/stages/rootssh/pubkeys) свой SSH-ключ, иначе не сможете потом залогиниться в систему, или не используйте стейдж `rootssh`.
* **Еще более важно**: прочитайте весь этот README целиком, чтобы понимать, что и зачем вы все-таки делаете.
