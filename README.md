# pi-builder
Удобный и расширяемый инструмент для сборки образов [Arch Linux ARM](https://archlinuxarm.org) для Raspberry Pi с использованием Docker.

### Проблема

Обычно для сборки операционок разработчики дистрибутивов используют набор shell-скриптов. У каждого дистрибутива они, как правило, свои. С их помощью создается чрут с нужными пакетами, правятся конфиги, добавляются пользователи и так далее. Таким образом обеспечивается необходимый минимум для успешной загрузки, работы и дальнейшей кастомизации оси руками конечного пользователя.

Однако, если вы создаете какой-то собственный продукт на основе обноплатного компьютера (маленький роутер, IP-камеру или систему управления умным домом, что угодно), скорее всего вам захочется как-нибудь задокументировать все изменения, которые вы внесли в свежеустановленную операционную систему и обеспечить себе возможность повторить эту конструкцию, не бояссь забыть о каком-нибудь важном действии, типа настройки sysctl.

Типичное решение в этом случае - написать большой и страшный скрипт, выполняющий все необходимые действия либо над развернутым на разработческой машине корнем, либо прямо на устройстве. При использовании chroot и [binfmt_misc](https://en.wikipedia.org/wiki/Binfmt_misc) и необходимости сохранения промежуточных успешных стадий сборки сложность подобных скриптов возрастает на порядок.

### Что предлагает pi-builder?
Pi-builder - это новый подход к сборке целевой операционной системы для готовых встраиваемых устройств. Он позволяет собирать образ так, как если бы это была не система для реальной железки, а обычный докер-контейнер. Сборка системы описывается стандартным синтаксисом [докерфайлов](https://docs.docker.com/engine/reference/builder) и выполняется в Docker на машине разработчика. Затем получившийся образ можно экспортировать на SD-карту и загрузить на Raspberry Pi.

### Что это дает?
* **Документирование и повторяемость сборок.** Докерфайлы - это практически готовая документация к последовательности действий, необходимых для настройки всей вашей системы.
* **Простота**. Ну серьезно, что может быть проще, чем собрать докер-контейнер?
* **Скорость и кеширование сборок**. Сборка целевой системы может состоять из сотен сложных и долго выполняющихся команд. С помощью Docker и его кешей вы можете не выполнять все эти команды каждый раз при сборке новой системы; сборка будет начинаться только с изменившихся команд, а результаты предыдущих будут браться из кеша.
* **Тестирование на реальном окружении**. Если вы разрабатываете какой-то софт, который должен работать на Raspberry Pi, совершенно логично тестировать его в том же окружении, в котором он будет работать на реальной железке - это избавит от многих потенциальных проблем.

### Как это работает?
Разработчики Arch Linux ARM (да и других систем) предоставляют для своих осей [архивы с минимальными корневыми ФС](https://mirror.yandex.ru/archlinux-arm/os/), которые можно развернуть на флешке и загрузиться с них. И поскольку это обычные корни, из них можно сделать собственный базовый образ для Docker с помощю механизма [FROM scratch](https://docs.docker.com/develop/develop-images/baseimages). Однако этот образ будет содержать исполняемые файлы и библиотеки с архитектурой ARM, и если ваша машина работает под другой архитектурой (скажем, x86_64), то ни одна команда внутри этого образа у вас не запустится.

Для того, чтобы иметь возможность исполнять файлы с другой архитектурой, ядро Linux имеет специальный механизм [binfmt_misc](https://en.wikipedia.org/wiki/Binfmt_misc), который позволяет установить кастомный интерпретатор для любой другой архитектуры, отличной от системной. Таким образом, можно настроить binfmt_misc для запуска ARM-бинарников с помощью эмулятора (в нашем случае - qemu-arm-static). Pi-builder содержит [небольшой скрипт](https://github.com/pi-kvm/pi-builder/blob/master/tools/install-binfmt), настраивающий в вашей системе binfmt_misc, чтобы иметь возможность запускать исполняемые файлы на ARM.

Сборка операционной системы в терминологии pi-builder делится на _стейджи_, представляющие какой-либо аспект настройки оси. Например, стейдж [ro](https://github.com/pi-kvm/pi-builder/tree/master/stages/ro) включает в себя Dockerfile.part с необходимыми инструкциями, чтобы сделать на системе read-only корень, и конфиги для этого. Другой пример - стейдж [watchdog](https://github.com/pi-kvm/pi-builder/tree/master/stages/watchdog) включает все необходимое для настройки вачдога с оптимальными параметрами на Raspberry Pi.

Полный список стейджей, идущих в комплекте с pi-builder, можно посмотреть [тут](https://github.com/pi-kvm/pi-builder/tree/master/stages). При сборке системы вы сами решаете, какие стейджи вам необходимы, и просто включаете их в вашу конфигурацию. По сути, стейджи - это кусочки докерфайлов которые при сборке склеиваются в указанной последовательности в один большой Dockerfшle и содержат все инструкции, которые будут выполнены на собираемой системе.

Последовательность сборки выглядит так:
1. Pi-builder скачивает статически скомпилированный qemu-arm-static от Debian и настраивает binfmt_misc глобально на вашей машине.
2. Далее скачивается образ Arch Linux ARM и заряжется в Docker в качестве базового образа.
3. Производится сборка конейнера с необходимыми стейджами - установка пакетов, настройка конфигов, чистка и так далее.
4. В получившемся контейнере можно запустить оболочку с помощтю `docker run`, чтобы проверить, все ли в порядке.
5. С помощью утилиты [docker-extract](https://github.com/pi-kvm/pi-builder/blob/master/tools/docker-extract) контейнер извлекается из внутреннего хранилища докера и помещается в каталог как обыкновенная развернутая корневая ФС.
6. Готовую ФС можно скопировать на SD-карту и загрузить с нее Raspberry Pi.

### Как этим пользоваться?

Для сборки системы с помощью pi-builder вам понадобится свежий Docker с возможностью запуска контейнера в привелегированном режиме (он требуется для установки binfmt_misc, форматирования SD-карты и некоторых других операций).

Вся работа с pi-builder выполняется через главный [Makefile](https://github.com/pi-kvm/pi-builder/blob/master/Makefile). В его начале  находятся параметры, доступные для изменения; все остальные, начинающиеся с символа `_`, менять не рекомендуется, только если вы точно не знаете, что делаете.

```Makefile
CARD ?= /dev/mmcblk0  # Путь к вашей SD-карте, на нее будет устанавливаться собранная система командой make install
CARD_BOOT ?= $(CARD)p1  # Раздел для /boot
CARD_ROOT ?= $(CARD)p2  # Раздел для /

PLATFORM ?= rpi  # Целевая платформа для Raspberry Pi; rpi-2 для Raspberry Pi 2
STAGES ?= __init__  # Список необходимых стейджей, об этом подробнее ниже

PROJECT ?= common  # Пространство имен для промежуточных образов, просто назовите как нравится
BUILD_OPTS ?=  # Всякие дополнительные опции для docker build
QEMU_ARM_STATIC_PLACE ?= /usr/bin/qemu-arm-static  # Путь к qemu-arm-static ВНУТРИ КОНТЕЙНЕРА
HOSTNAME ?= pi  # Имя хоста для получившейся системы
LOCALE ?= en_US.UTF-8  # Локаль будущей системы
TIMEZONE ?= Europe/Moscow  # Таймзона будущей системы
REPO_URL ?= http://mirror.yandex.ru/archlinux-arm  # Зеркало пакетов и всего загружаемого контента
```

Самые важные параметры - это `PLATFORM`, определяющий, под какую плату нужно собрать систему, и `STAGES`, указывающий, какие стейджи необходимо включить.

Например, вот так выглядит сборка системы с read-only корнем и вачдогом (выдержка из Makefile). Ее можно активировать с помощью команды `make rpi2`:
```Makefile
rpi2: binfmt
	make _rpi \
		PLATFORM=rpi-2 \
		BUILD_OPTS="--build-arg NEW_SSH_KEYGEN=$(shell uuidgen)" \
		STAGES="__init__ os watchdog ro rootssh __cleanup__"
```

Стейдж `__init__` всегда должен идти первым - он содержит инициализирующие инструкции для создания базового образа системы `FROM scratch`. Далее идут стейджи для "обживания" системы - установки полезных пакетов, настройки вачдога, приведения системы к read-only, настройки ключей SSH для рута и очистки от временных файлов.

Вы можете создать собственные стейджи и включить их в сборку. Для этого просто заведите каталог для вашего стейджа в папке `stages` и разместите в нем файл `Dockerfile.part` по аналогии с любым другим стейджем. Либо можете сделать так, как это устроено в проекте [Pi-KVM](https://github.com/pi-kvm/pi-kvm/tree/master/os) (для которого, собственно, pi-builder и создавался).

### Комплектные стейджи
* `__init__` - главный стейдж, формирующий базовый образ на основе корневой ФС Arch Linux ARM. Он ВСЕГДА должен идти первым в списке `STAGES`. 
* `os` - просто ставит некоторые пакеты и настраивает систему, чтобы жить в ней было несколько более комфортно. Просто [посмотрите его содержимое](https://github.com/pi-kvm/pi-builder/tree/master/stages/os).
* `ro` - превращает систему в read-only-ось. В таком режиме Raspberry Pi можно просто выключать из розетки без предварительной подготовки, не боясь потери данных или коррапта файловой системы. Для того, чтобы временно включить систему на запись (чтобы поставить пакеты, например), используйте команду `rw`, после всех изменений выполните команду `ro` для обратного перемонтирования в read-only.
* `watchdog` - настраивает аппаратный вачдог, никакой магии.
* `rootssh` - удаляет пользователя `alarm`, блокирует пароль `root` и добавляет в его `/root/.ssh/authorized_keys` ключи из каталога [stages/rootssh/pubkeys]. По умолчанию там лежат ключи разработчика pi-builder :D Кроме того, при в `BUILD_OPTS` параметра `--build-arg NEW_SSH_KEYGEN=$(shell uuidgen)`, на этом стейдже будет всегда происходить пересборка системы, поскольку в конце него выполняется команда `ssh-keygen` для генерирования уникальных хостовых ключей. В обычной ситуации ее ручной запуск не требуется, но если система загружается в read-only, у SSH нет возможности сгенерировать ключи самостоятельно даже при первой загрузке.
* `__cleanup__` - удаляет всякий мусор во временных папках, оставшийся от сборки.

### TL;DR
Как собрать систему и поставить ее на флешку:
```shell
$ make rpi2
$ make install
```

Как собрать систему со своим списком стейджей:
```shell
$ make _rpi PLATFORM=rpi-2 STAGES="__init__ os __cleanup__"
```

Остальные команды можно посмотреть так:
```shell
$ make
Available commands:
    make           # Print this help
    make rpi|rpi2  # Build Arch-ARM rootfs
    make shell     # Run Arch-ARM shell
    make binfmt    # Before build
    make scan      # Find all RPi devices in the local network
    make clean     # Remove the generated rootfs
    make format    # Format /dev/mmcblk0 to /dev/mmcblk0p1 (vfat), /dev/mmcblk0p2 (ext4)
    make install   # Install rootfs to partitions on /dev/mmcblk0
```

* **Важно**: проверьте в Makefile путь к SD-карте в переменных `CARD*`.
* **Очень важно**: положите в каталог [stages/rootssh/pubkeys](https://github.com/pi-kvm/pi-builder/tree/master/stages/rootssh/pubkeys) свой SSH-ключ, иначе не сможете потом залогиниться в систему.
* **Еще более важно**: все-таки прочитайте весь этот README целиком, чтобы понимать, что и зачем делаете.
